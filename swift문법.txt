swift 변수사용법

//상수
//let a: Int = 100
let a: Int = 100

a = 200 //에러난다(상수니까 안변한다)
   
//변수
//var 변수명: 데이터 타입 = 값
var b: Int = 200
   
//변수타입
var someInt: Int = -100
someInt = 100 //부호가 잇든없든 가능
someInt = 1.1 //에러가 난다
   
//UInt (부호없는정수형)
var someUInt: UInt = 200
someUnit = -200 //에러가난다    

//Float
var someFloat: Float = 1.1
someFloat = 1 //에러가안난다
print(someFloat) // 1.0
   
//Double
var someDouble: Double = 1.1
someDouble = 1

//Bool
var someBool: Bool = true
someBool = false

//Character
var someCharacter: Character = "가"
someCharacter = "A"
   
//String
var someString: String = "안녕하세요"

//타입추론 -> 자동으로 변수타입을 판단해준다 즉, 변수타입생략가능
var number = 100

--------------------------------------------------
//컬렉션타입 -> 데이터들의 집합묶음

Array -> 데이터 타입의 값들을 순서대로 지정하는 리스트
Dictionary -> 순서없이 키와 값(value) 한 쌍으로 데이터를 저장하는 컬렉션타입
Set -> 같은 데이터 타입의 값을 순서없이 저장하는 리스트(중복xxx)

//순서대로 담긴다
var numbers: Array<Int> = Array<Int>()
numbers.append(1)
numbers.append(2)
numbers[0]
numbers[1]

//중간삽입
numbers.insert(4,at:0)  //0번째 요소애 4를 삽입
[4,1,2] //이렇게 뒤로밀린다

//삭제
numbers.remove(at: 0)
numbers //출력

//간단하게 생성
var names = [String]()
var names = [String] = []

//딕셔너리
var dic: Dictionary<String, Int> = Dictionary<String, Int>()
//간단하게
var dic: [String: Int] = [:]
var dic: [String: Int] = ["권태안" : 1]
dic["김철수"] = 3 //키값은 김철수 값은 3
dic //출력 -> ["권태안":1,김철수":3]

dic["김민지"] = 6 //값변경
dic.removeValue(forKey: "김민지") //삭제

//세트는 축약형으로 선언할수없어서 그냥 이렇게만 써야한다
var set: Set = Set<Int>()
set.insert(10)
set.insert(20)
set.insert(20) //중복된값 xxx
set //순서없이 출력

//삭제(순서가없으니 값으로 삭제)
set.remove(20)
   
========================================================
#)함수
func 함수명(파라미터 이름:데이터 타입)->반환타입 {
    return 반환값
}

func sum(a: Int, b:Int) -> Int {
    return a+b
}
//호출
sum(a: 5, b: 3)
   

func hello() -> String {
    return "hello"
}
//호출
hello()
   
#)반환값이 없는
func printName() {
   
}

func greeting(friend: String, me:String="gunter") {
    print("Hello, \(friend)! I'm \(me)") //문자열안에 변수사용시 역슬래시사용
}

greeting(friend: "Albert") //출력: Hello, Albert! I'm gunter


#)전달인자 레이블사용(사용자가 명확하게 알수있는게 장점)
func sendMessage(from myName: String, to name: String) -> String {
    return "Hello \(name)! I'm \(myName)"
}

sendMessage(from: "Gunter", to: "Json") //출력: Hello Json! I'm gunter

   
//가변매개변수
func sendMessage(me: String, friends: String...) //이렇게 점을 붙이면 가변매개변수다.(배열이 넘어온다고 생각)
    -> String {
    return "Hello \(friends)! I'm \(me)"
}

sendMessage(me: "Gunter", friends: "Json", "Albert", "Stella") //출력: Hello ["Json","Albert","Stella"]! I'm Gunter

========================================
#)조건문
let age = 20
if age < 19 {
    print("미성년자 입니다.")
}

----------
if age < 19 {
    print("미성년자")
}
else {
    print("성년자")
}

---------
let animal = "cat"
if animal == "dog" {
    print("강아지 사료 주기")
}
else if animal == "cat" {
    print("고양이 사료 주기")
}
else {
    print("해당하는 동물 사료가 없음")
}
=======================================
#)switch
let color = "green"
switch color {
    case "blue" :
        print("파란색입니다.")
    case "green":
        print("초록색입니다")
    case "yellow":
        print("노란색 입니다")
    default:
        print("찾는색상이 없습니다")
}

-------------------
let temperature = 30
switch temperature {
    case -20...9:
        print("겨울입니다")
    case 10...14:
        print("가을입니다")
    case 15...25:
        print("봄 입니다")
    case 26...35:
        print("여름입니다")
    default:
        print("이상기후입니다")
}
-------------------
#)반복문

for i in 1...4 {
       print(i)
}

-------------------
let array=[1,2,3,4,5]

for i in array {
    print(i)
}

-----------------------
var number = 5

while number < 10 {
    number+=1
}

number값이 10이된다

------------------------
var x = 6

repeat { //적어도 1번은 반드시 실행된다(조건이 안맞아도)
    x+=2
}while x<5 //일때 실행

print(x) //8이 출력된다

------------------------
#)옵셔널(값이 있을수도있고 없을수도있다)

var name: String? //이렇게 선언하면 초기값을 지정하지 않더라도 null인 nil이 들어가게된다 name은 옵셔널변수가 되는것이다

var optionalName: String? = "Gunter"
print(optionalName) //출력: Optional("Gunter") 이말은 Gunter문자열이 옵셔널이라는 포장지로 감싸져있다는 말이다 -> 포장지를 벗기지않으면 일반타입과 연산, 선언할수없다
var requiredName: String = optionalName //이렇게 하면 에러난다. requiredName변수는 옵셔널변수가 아니기때문이다. 즉 타입이다르다

------------------------
#)옵셔널해제 방법
1) 명시적 해제 첫번째방법(강제해제) //이방법은 위험하다 만약에 값이 nil인 옵셔널을 강제해제하면 프로그램이 에러가난다

var number: Int? = 3
print(number) //출력: Optional(3)
print(number!) //출력: 3 (강제해제)

2) 명시적해제 두번째방법(비강제해제) -> if로 바인딩을 하면 if문안에서만 추출된 변수를 쓸쑤잇다 그래서 3번째 가드방법을 쓴다
if let result = number { //number는 위에서 선언된 옵셔널변수를 써야한다
    print(result) //옵셔널을 추출해서 할당받은 result
    //출력: 3 (포장지가 벗겨졌다)
} else {
    //값 추출 실패시 실행
}

3) 세번째방법(가드문)
func test() {
    let number: Int? = 5
    guard let result = number else {return}
    print(result)
}

test() //출력: 5

--------------------------
#)묵시적 해제 -> 컴파일이 자동으로 해제
let value: Int? = 6
if value == 6 {
    print("value가 6입니다.")
} else {
    print("value가 6이 아닙니다.")
}
//출력: value가 6입니다 -> 옵셔널값을 비교연산으로 다른값과 비교하면 자동으로 포장지를 벗겨주기때문에 if절이실행된다

#)묵시적 두번째방법(옵셔널해제)
let string = "12"
var stringToInt: Int! = Int(string) //문자열을 정수로 바꿔주는데 만약에 문자열에 숫자가아닌 한글,문자등이 들어가면 nil을 반환하기때문에 이렇게 옵셔널로 선언해야한다
print(stringToInt + 1) //13
 
==========================
#)구조체
struct User {
    var nickname: String
    var age: Int

    func information() {
        print("\(nickname) \(age)")
    }
}

//User 인스턴스 생성
var user = User(nickname: "gunter", age: 23)

user.nickname   //실행결과: "gunter"
user.nickname = "ablert"
user.nickname   //실행결과: "ablert"

user.information()  //ablert 23

==========================
#)클래스
class Dog {
    var name: String = ""
    var age: Int = 0
   
    //기본생성자
    init() {
    }
   
    func introduce() {
        print("name \(name) age\(age)")
    }
}

//인스턴스생성
var dog = Dog()
dog.name = "CoCo"
dog.age = 3
dog.name
dog.age

dog.introduce()  //name CoCo age 3

=======================================
#)초기화구문 init
struct User {
    var nickname: String = "Gunter"
    var age: Int = 0
   
    init() {
     //인스턴스가 생성되면 호출
     //인스턴스 생성시 필요한 설정을 해주는 코드 작성
     //프로퍼티 초기화 가능
    }
}

let user = User() //이때 init호출

======================================
class User {
    var nickname: String
    var age: Int
   
    init(nickname: String, age: Int) {
        self.nickname = nickname
        self.age = age
    }
    init(age: Int) {
        self.nickname = "ablert"
        self.age = age
    }
   
    //클래스만가능
    deinit {
        print("deint user")
    }    
}

var user = User(nickname: "gunter", age: 23)
user.nickname  // "gunter"
user.age       //23

var user2 = User(age: 27)
user2.nickname  //"ablert"
user2.age        //27

//스위프트는 인스턴스가 더이상필요하지 않으면 자동으로 메모리에서 소멸된다.
//nil을 넣으면 인스턴스가 더이상 필요하지 않다고 판단해서 deinit이 호출된다.
var user3 : User? = User(age: 23)
user3 = nil   //deint user


==================================================
#)프로퍼티
1. 저장 프로퍼티(인스턴스에 프로퍼티값이 저장된거)

struct Dog {
    var name: String
    let gender: String //상수는 값 변경불가
}

var dog = Dog(name :"gunter", gender: "Male")
print(dog)  //"Dog(name: "gunter", gender: "Male")\n"

dog.name="권태안"
dog.gender="Femal" //상수라 에러가 난다

//구조체 변수타입을 상수로 선언하면 내부 프로퍼티도 상수로 다 바뀐다
let dog2 = Dog(name: "gunter", gender: "male")
dog2.name = "권태안"  //에러가난다.
==================================================

#)클래스는 참조타입이여서 가능하다.(구조체는 값 타입)
class Cat {
    Var name: String
    let gender: String
   
    init(name: String, gender: String)  {//매개변수로 받고
        self.name = name
        self.gender = gender
    }
}

let cat = Cat(name: "json", gender: "male")
cat.name="gunter" //이렇게 let으로 클래스타입을 설정해도 값이 바뀐다.
cat.gender="female" //상수라 에러난다.
print(cat.name)

==========================================
#) 2. 연산형 프로퍼티
   struct Stock {
    var averagePrice: Int
    var quantity: Int
    var purchasePrice: Int { //이렇게 getter, setter를 통해서 값을 연산하고 프로퍼티에 전달해주는게 연산형프로퍼티이다
        get {
            return averagePrice * quantity
        }
        set(newPrice) {  
            averagePrice = newPrice / quantity
        }
        //set매개변수 생략시
        //set {
        //    averagePrice = newValue / quantity
        //}
    }
}

var stock = Stock(averagePrice: 2300, quantity: 3) //저장프로퍼티
print(stock) //"Stock(averagePrice: 2300, quantity: 3)\n"
stock.purchasePrice  //6900
stock.purchasePrice = 3000   //set코드 실행
stock.averagePrice  //1000

=======================================
#) 3. 프로퍼티 옵저버 -> 프로퍼티가 set될때마다 호출
옵저버에는 두가지가 있는데 값이 저장되기 직전에 호출되는 willSet
값이 저장된 직후에 호출되는 didSet 옵저버가 있다.

class Account {
    var credit: Int = 0 {
        //소괄호 이름 지정
        willSet {
            print("잔액이 \(credit)원에서 \(newValue)원으로 변경될 예정입니다.") //매개변수 정하지않으면 자동으로 newValue
        }
        didSet {
            print("잔액이 \(oldValue)원에서 \(credit)원으로 변경되었습니다.") //매개변수 지정하지않으면 자동으로 oldValue
        }
    }
}

var account = Account()
account.credit = 1000 //잔액이 0원에서 1000원으로 변경될 예정입니다.
                      //잔액이 0원에서 1000원으로 변경되었습니다.
                     
=================================
#) 타입프로퍼티(인스턴스생성없이 접근)
struct SomeStructure {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 1
    }
}

SomeStructure.computedTypeProperty  //1
SomeStructure.storedTypeProperty //Some value
SomeStructure.storedTyleProperty = "hello"
SomeStructure.storedTypeProperty //hello

================================================
#)클래스와 구조체 차이점
클래스
- 참조타입
- 상속이가능
- deinit을 사용하여 클래스 인스턴스의 메모리 할당을 해제할수있다
- 같은 클래스 인스턴스를 여러개의 변수에 할당한 뒤 값을 변경 시키면 모든 변수에 영향을 준다(메모리가 복사됨)

구조체
- 값 타입
- 구조체 변수를 새로운 변수에 할당할 때마다 새로운 구조체가 할당된다
- 즉 같은 구조체를 여러개의 변수에 할당한 뒤 값을 변경시키더라도 다른 변수에 영향을 주지 않음(값 자체를 복사)

class SomeClass {
    var count: Int = 0
}

struct SomeStruct {
    var count: Int = 0
}

//같은 클래스인스턴스를 할당한 변수 값을 변경시키면 참조된 인스턴스의 값이 변경된다
var class1 = SomeClass()
var class2 = class1
var class3 = class1
class3.count = 2
class1.count //2  -> class3 값을 바꾸었지만 class1도 바뀐것을 확인


//구조체 -> 매번새로운 메모리 할당
var struct1 = SomeStruct()
var struct2 = struct1
var struct3 = struct1

struct2.count = 3
struct3.count = 4

struct1.count  //0
struct2.count  //3
struct3.count  //4
====================================================
#)상속
class Vehicle {
   //final var currentSpeed = 0.0 -> 재정의 할 수없다. override var current ~ 불가능
    var currentSpeed = 0.0
    var description: String {
        return "traveling at \(currentSpeed) miles per hour"
    }
    func makeNoise() {
        print("speaker on")
    }
}

//상속받는 클래스 정의하기
class Bicycle: Vehicle {  //Vehicle를 상속받음
    var hasBasket = false
}

var bicycle = Bicycle()
bicycle.currentSpeed  //0 -> 부모값을 가져올수있다
bicycle.currentSpeed=15.0  //값 변경가능

//Vehicle를 상속받는 또 다른 클래스 선언
//오버라이딩
class Train: Vehicle {
    override func makeNoise() {
        super.makeNoise()
        print("choo choo")
    }
}

let train = Train()
train.makeNoise() // speaker on choo choo -> 필요에따라 super를 붙여서 부모먼저실행 후 본인꺼 실행 가능

======================================================
#)프로퍼티 오버로딩
class Car: Vehicle {
    var gear = 1
    override var description: String {
        return super.description + " in gear \(gear)"
    }
}

let car = Car()
car.currentSpeed = 30.0
car.gear = 2
print(car.description) // traveling at 30.0 miles per hour in gear 2

======================================================
class AutomaticCar: Car {
    override var currentSpeed: Double {
        didSet {
            gear = Int(currentSpeed / 10) + 1
        }
    }
}
let automatic = AutomaticCar()
automatic.currentSpeed = 35.0  //값을 바꾸는 순간 didSet 실행
print("AutomaticCar: \(automatic.description)") //AutomaticCar: traveling at 35.0 miles per hour in gear 4

================================================
#)타입캐스팅
class MediaItem {
    var name: String
    init(name: String) {
        self.name = name
    }
}

class Movie: MediaItem { //상속
    var director: String
    init(name: String, director: String) {
        self.director = director
        super.init(name: name)
    }
}

class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}

let library = [
    Movie(name: "기생충", director: "봉준호"),
    Song(name: "Butter", artist: "BTS"),
    Movie(name: "올드보이", diector:"박찬욱"),
    Song(name: "Wonderwall", artist: "Oasis"),
    Song(name: "Rain", artist: "이적")
]

var movieCount=0
var songCount=0

for item in library {
    if item is Movie { //is 연산자를 사용해서 타입확인
        movieCount += 1
    } else if item is Song {
        songCount += 1
    }
}

print("Media library contains \(moiveCount) movies and \(songCount) songs")
-> "Media library contains 2 movies and 3 songs"

for item in library {
    if let movie = item as? Movie { // as? -> 다운캐스팅(option로반환->optional를 꺼내기위해 if문을 썻다), as! -> 다운캐스팅이지만 확실할때 쓰기
        print("Movie: \(movie.name), dir. \(movie.director)")
    } else if let song = item as? Song { //다운캐스팅된 타입에 접근
        print("Song: \(song.name), by \(song.artist)")
    }
}

-->출력
Movie: 기생충, dir. 봉준호
...

======================================================
#)assert와 guard

assert
- 특정조건을 체크하고, 조건이 성립되지 않으면 메시지를 출력하게 할 수 있는 함수
- assert 함수는 디버깅모드에서만 동작하고 주로 디버깅 중 조건의 검증을 위하여 사용한다

guard문
- 뭔가를 검사하여 그다음에 오는 코드를 실행할지 말지 결정하는 것
- guard문에 주어진 조건문이 거짓일 때 구문이 실행됨

var value = 0
assert(value == 0) // value가 0인지 -> 에러 발생안한다

value = 2
assert(value == 0, "값이 0이 아닙니다.") // 런타임에러가 발생한다 -> 조건이 성립되지않으면 에러


//guarad문
return or throw or break를 통해 이 후 코드를 실행되지 않도록 한다

func guardTest(value: Int) {
    guard value == 0 else {return} //value가 0일때만 안녕하세요 출력
    print("안녕하세요")
}

guardTest(value: 2) //아무것도 출력안됨 guard문에 막혀서

//guard문을 통해 옵셔널 바인딩
func guardTest(value: Int?) {
    guard let value = value else {return}
    print(value)
}

guardTest(value: nil) //막혀서 출력이 안된다

==========================================================
#)프로토콜

protocol SomeProtocol {
   
}

protocol SomeProtocol2 {

}

struct SomeStructure: SomeProtocol, Someprotocol2 { //이렇게하면 SomeStructure구조체에 SomeProtocol이 채택된것이다
   
}

=====================================
protocol FirstProtocol {
    var name: Int {get set}
    var age: Int {get} //읽기전용
}

protocol AnotherProtocol {
    static var someTypeProperty: Int {get set}
}

protocol FullyNames {
    var fullName: String {get set}
    func printFullName()
}

struct Person: FullyNames {
    var fullName: String  //프로토콜을 준수하게 fullName을 선언
    func printFullName() { //프로토콜을 준수하게 함수선언
        print(fullName)        
    }
}

protocol SomeProtocol3 {
    func someTypeMethod()
}

protocol SomeProtocol4 {
    init(someParameter: Int)
}


protocol SomeProtocol5 {
    init()
}

class SomeClass: SomeProtocol5 {
    //클래스에서 프로토콜이 요구하는 생성자를 채택하려면 required선언해야한다
    required init() {  //상속받지않은 클래스면 required안붙여도된다
       
    }
}

====================================
#)익스텐션
extension Int {
    var isEven: Bool {
        return self % 2 == 0 //짝수인지 판단
    }
   
    var isOdd: Bool {
        return self % 2 == 1
    }
}

var number = 3
number.isOdd  //true
number.isEven //false

-----------------
extension String {
    func convertToInt() -> Int? {
        return Int(self) //문자열을 int타입으로
    }
}

var String = "0"
string.convertToInt() // 0

=====================================
#)열거형 -> 연관성있는 값들을 모아놓은 것 (enum사용)
enum CompassPoint {
    case north
    case south
    case east
    case west
}

var direction = CompassPoint.east  //east
direction = .west   //위에서 한번 선언했기때문에 생략가능하다 타입추론을 알아서한다.  -> west

switch direction {
    case .north:
        print("north")
    case .south:
        print("south")
    case .east:
        print("east")
    case .west:
        print("west") //이게 출력된다 (위에서 west로 선언했으니)
}

======================================
enum CompassPoint: String { //원시값선언가능 -> rawValue로 출력가능
    case north ="북"
    case south ="남"
    case east = "동"
    case west ="서"
}

var direction = CompassPoint.east  //east
direction = .west   //위에서 한번 선언했기때문에 생략가능하다 타입추론을 알아서한다.  -> west

switch direction {
    case .north:
        print(direction.rawValue)
    case .south:
        print(direction.rawValue)
    case .east:
        print(direction.rawValue)
    case .west:
        print(direction.rawValue) //서
}

let direction2 = CompassPoint(rawValue: "남") //CompassPoint인스턴스생성 -> direction2 상수에 south가 들어간다

//핸드폰 에러를 정의하는 열거
enum PhoneError {
    case unknown
    case batteryLow(String) //연관값
}

let error = PhoneError.batteryLow("배터리가 곧 방전됩니다.") //batteryLow("배터리가 곧 방접됩니다.")

switch error {
    case .batteryLow(let message) //연관값을 넘겨받기위해 let선언
        print(message)


    case .unknown:
        print("알수없는 에러입니다")
}

======================
#)옵셔널 체이닝
옵셔널에 속해있는 nil일지도 모르는 프로퍼티, 메서드, 서브스크립션 등을 가져오거나 호출할 때 사용할 수 있는 일련의 과정

struct Developer {
    let name: String
}

struct Company {
    let name: String
    var developer: Developer?
}

var company = Company(name: "Gunter", developer: nil)
print(company.developer) //nil

-------------------
struct Developer {
    let name: String
}

struct Company {
    let name: String
    var developer: Developer?
}

var developer = Developer(name: "han")
var company = Company(name: "Gunter", developer: developer)
print(company.developer) //옵셔널로 감싸진 developer출력
print(company.developer.name) //에러가 난다. -> developer는 옵셔널로 감싸져있어서 접근이 불가능

//이렇게 옵셔널 바인딩없이 옵셔널 체이닝을 이용하면 쉽게 값을 접근 할수있다
print(company.developer?.name) //Optional("han") -> 값이 nil일수도있어서 옵셔널로 감싸짐
print(company.developer!.name)// han

=====================================
#) try~catch

enum PhoneError: Error {
    case unknown
    case batteryLow(batteryLevel: Int) //연관갑설정
}

throw PhoneError.batteryLow(batteryLevel: 20)  //throw구문에서 에러발생 -> 아래쪽 catch에서 PhoneError.batteryLow를 찾아간다.

func checkPhoneBatteryStatus(batteryLevel: Int) throws -> String{ //반환값이 String
    guard batteryLevel != -1 else {throw PhoneError.unknown} //unknown에러를 던진다 //guard문은 false일때 else문 실행되고 함수가 조기종료된다
    guard batteryLevel >= 20 else {throw
        PhoneError.batteryLow(batteryLevel: 20)}
    return "배터리 상태가 정상입니다." //위에 guard조건이 다 안걸리면 반환값 던지기 //즉 정상적으로 입력받아야 두 가드문이 실행이 안되고 정상적으로 반환값이 출력된다
}


do {
    try checkPhoneBatteryStatus(batteryLevel: -1) //오류가 발생할수있는 코드
}catch PhoneError.unknown {
    print("알 수 없는 에러입니다.")
}catch PhoneError.batteryLow(let batteryLevel) {
    print("배터리 전원 부족 남은 배터리: \(batteryLevel)%")
} catch { //아무것도 안하면 지역상수인 error 사용할수있다.
    print("그 외 오류 발생: \(error)")
}


//또다른 에러처리
let status = try? checkPhoneBatteryStatus(batteryLevel: -1)
print(status) //status가 unknown이기때문에 nil이 출력이 된다.

//만약 함수가 에러를 던지지않는다면
let status = try? checkPhoneBatteryStatus(batteryLevel: 30)
print(status) //Optional("배터리 상태가 정상입니다.")

//또 다른 에러처리(try!) -> 에러가 발생하지 않을 거라는 확신이있을때 -> 만약에 에러발생시 런타임에러발생
let status2 = try! checkPhoneBatteryStatus(batteryLevel: 30)
print(status2)

======================================================
#)클로저 -> 익명이긴 하지만 함수이다.

let hello = { () -> () in      //파라미터, 리턴타입이 없어서 () -> ()선언함
    print("hello")
}

hello()

//파라미터와 리턴타입이 있는 경우
let hello2 =  { (name: String) -> String in
    return "Hello, \(name)"
}

hello2(name: "Gunter") //파라미터 전달하면 에러가된다. 즉, 클로저는 전달인자레이블을 생략하고 던져야한다
hello2("Gunter")  //Hello, Gunter

--------------
func doSomething(closure: () -> ()) { //파라미터이름은 closure
    closure()
}

doSomething(closure: { () -> () in  //doSomething함수호출시 위에 선언된 closure() 실행되서 print실행
    print("hello")  
})

//또 다른 방법
doSomething() { //이렇게 바로 클로저를 정의할 수있다. //파라미터와 반환값이 없는 클로저를 전달받은거니 이렇게 클로저를 정의할때 생략가능, in 키워드도 생략가능
    print("hello2")
}

//또 다른방법(doSomething처럼 단 한개 클로저만 매개변수로 전달하는 경우는 소괄호 생략가능)
doSomething {
    print("hello3")
}


-----------------
func doSomething2() -> () -> () {  //반환타입으로 파라미터와 반환타입이 없는 클로저 작성
    return { () -> () in
        print("hello04")
    }
}

doSomething2()() //hello4

//매개변수에 클로저가 여러개 있는 경우
func doSomething2(success: () -> (), fail: ()->()) {

}

doSomething2 {
    code
} fail: {
    code
}

--------------------
//간단한 표현방법들
func doSomething3(closure: (Int, Int, Int) -> Int) {//매개변수로 clousre를 받고있는데 클로저의 매개변수로 Int 3개를 받고있고 Int타입반환
    closure(1,2,3)
}

doSomething3(closure: {(a,b,c) in    //이렇게 길었던 클로저 선언이 맨아래 표현간소화를 통해 짧아졌다
    return a+b+c
})

doSomething3(closure: {
    return $0+$1+$2
})

doSomething3(closure: {
    $0+$1+$2  //단일문이면 return 생략가능
})

doSomething3() {
    $0+$1+$2
}

doSomething3 {  //단하나의 클로저를 매개변수로 전달하면 소괄호생략가능
    $0+$1+$2
}

==============================================
#)고차함수
다른함수를 전달인자로 받거나 함수실행의 결과를 함수로 반환하는 함수
map, filter, reduce

//map
let numbers=[0,1,2,3]
let mapArray = numbers.map {(number) -> Int in
    return number * 2
}
print("map \(mapArray)")  //map [0,2,4,6]\n"

//filter
let intArray = [10,5,20,13,4]
let filterArray = intArray.filter {$0 > 5}
print("filter \(filterArray)")  //filter [10,20,13]\n"

//reduce -> 하나로 통합
let someArray = [1,2,3,4,5]
let reduceResult = someArray.reduce(0) {  //첫 매개변수를 0으로 초기화 즉 0부터 더한다 //이것도 클로저다
    (result: Int, element: Int) -> Int in
    print("\(result) + \(element)")
    return result + element
}
print("reduce \(reduceResult)")  //reduce 15

===============================================
#) 클로저라고 하면 보통 익명함수를 뜻하는 걸로 알텐데 
func 키워드를 이용해 이름을 붙여주는 함수들도 모두 클로저이다.

클로저에는 Named Closure, Unnamed Closure 가있다.

우리가 선언해왔던 이름이 있는 함수는
func doSomething() {
	print("Somaker");
}
이런게 NamedClosure이다.

-----------------------
//이런게 익명함수이고 Unnamed Closure이다.
//즉, 클로저는 NamedClosure, UnnamedClosure 둘다포함하지만 보통 UnnamedClosure를 말한다.
let closure = { print("Somaker")}

-----------------------
func란 키워드로 선언되는 것은 함수이자 NameClosure이고
이 함수가 클래스,구조체,열거형에 속해있으면 메서드라고 부른다. ---> 이게 함수와 메서드의 차이이다.

func name(parameters) -> Return Type {
}

--------------------------
//파라미터를 선언하는 방식은 크게 세가지가 있다.
1) Argument Label과 Parameter Name 각각 명시하기
Argument Label: 함수를 호출할 때 사용하는 이름
Paramter Name: 함수 내에서 사용할 파라미터의 이름

func sayHello(to name: String) {
	print("Hello, \(name)");
}
sayHello(to: "Sodeul")

여기서 Argument Label은 to에 해당하고 함수를 호출할 때 사용된다.
Parameter Name은 name에 해당된다.

근데, 우린 지금껏 print함수를 쓸 때 print("Somaker") 이렇게 to 없이 썻는데????
이거는 print 함수를 보면 func print(_ items: Any...) 이렇게 되있는데
Argument Lable을 언더바로 표현하고있다.
그래서 Argument Lable을 생략하고 싶으면, _를 사용해서 생략할수있음
이거를 wildcard Pattern 이라고 한다.

따라서 다음과 같이 wildcard Pattern을 이용해 Argument Lable을 생략한 함수는 아래와같다.

func sayHello(_ name: String) {
	print("Hello, \(name)")
}

호출해보자
sayHello("Sodeul")

단, ParameterName은 생략못한다.
---------------------------------
2) Argument Label & Parameter Name을 한번에 명시하기 -> to를 name으로 파라미터와 일치시키면 호출할때 편하자낭~

이렇게 하나만 선언한경우 name이 Argument Label이자 Parameter Name이 되는 것이다.

func sayHello(name: String) {
	print("Hello, \(name)")
}

sayHello(name: "Sodeul")

----------------------------------
3) 파라미터를 받지 않는 경우
func sayHello() {}

----------------------------------
#)리턴타입
func sayHello(name: String) -> String {
	return name;
}

#) 리턴타입이 없는 경우
func sayHello(name: String) {}

----------------------------------
#) 파라미터로 전달되는 Value 타입의 값은 복사된 상수값이다.
Value타입은 int,string 같은 자료형을 말하는 것이다.

func sayHello(name: String) {}
그리고 다음과 같이 "Sodeul" 이라는 값을 가진

var name: String = "Sodeul"
sayHello(name: name)

name이란 변수의 값을 함수의 파라미터로 넘겨줬다.
이러면 sayHello라는 함수가 실행될 당시,
name이란 파라미터의 값인 "Sodeul"을 복사해서 파라미터로 가짐!!

그래서 sayHello함수가 실행되는 도중에 호출한 곳에서 name이란 변수를 바꿔도 함수내부엔 영향이 없다.


func sayHello(name: String) {
    DispatchQueue.main.asyncAfter(deadline: .now() + 3) { //메인이 먼저 실행된 후
        print("Check #2 \(name)"")
    }
}
 
var name: String = "Sodeul"
sayHello(name: name)
name = "Somaker"
print("Check #1 \(name)")

//결과
Check #1 Somaker
Check #2 Sodeul

또한 파라미터로 전달될 때 복사된 값은 상수라고 했기때문에 sayHello함수내부에서
name = "Somaker" 라고 재정의할수없다.
-------------------------------------
#) 위에서 파라미터의 value타입은 복사된 상수값이 전달되지만
   ReferenceType 값을 파라미터로 전달할 경우, 전달되는 주소값을 가지고온다.
   

class Human {
	var name: String
	var age: int
	
	init(name:String, age: Int) {
		self.name = name
		self.age = age
	}
}

---------
그래서 만약, 함수내부에서 전달된 인스턴스의 프로퍼티를 변경한다면?(위의 경우에 상수이기때문에 변경이안됬다)
func changeName(human: Human) {
	human.name = "Somaker" //재정의해도 에러가 안난다.
}

let sodeul = Human.init(name: "Sodeul", age: 10)
changeName(human: sodeul)
print(sodeul.name)

즉, 복사해서 전달하는게 아니라 참조에의한 전달이다.
=========================================================
#) 위에서 value타입은 복사,상수라 값변경이 안됬는데 방법이 있긴하다.

#) In-Out-Parameters: Value 타입의 값을 참조로 전달하는 방법
Value 타입의 값을 Reference 타입의 값처럼 참조로 전달하고 싶을 때

#)함수선언
함수파라미터 선언할 때 inout 키워드를 작성한다.
func sayHello(name: inout String) {}

#)함수호출
함수호출 할 때는 Argument 앞에 & 붙여주기

sayHello(name: &name)
------------------------------
//예제
func sayHello(name: inout String) {
	name = "Somaker" //이렇게 바꿀수가 있다.
}

var name: String = "Sodeul"
sayHello(name: &name)
print(name) //Somaker 가 출력된다.

------------------------------
#) 파라미터에 기본 값 설정하기

형식: (name: Type = 기본값)
파라미터의 Type 옆에  = (등호)를 넣어서 기본 값을 지정한다.

파라미터에 기본값을 설정한 경우 호출 시 파라미터를 생략해도된다.

#) 예제를 살펴보자 -> 아래처럼 = 를 통해 기본 값을 설정 할 수 있다.
func sayHello(name: String = "Stranger") {
	print("Hello, \(name)")
}

sayHello()  //"Hello, Stranger"
sayHello(name: "Sodeul") //"Hello, Sodeul"

//여기서 중요한 것은 기본값이 있는 파라미터는 생략이 가능하다.

-----------------------------------
#)가변 파라미터
하나의 파라미터가 여러 개의 아규먼트를 받을 때 사용한다.
가변 파라미터의 타입은 배열이다.
Type뒤에 ... 을 붙이면된다.

func printSum(of nums: Int...) {}
이럴경우 nums라는 가변파라미터는 nums: [Int] 이렇게 int형 배열이 된다.

가변파라미터는 ,(comma)를 이용해 여러 아큐먼트를 받는다.
단, 가변파라미터 바로 뒤에 있는 파라미터는 무조건 Argument Label을 가져야한다.
컴파일러 입장에서 어디까지 ,(comma)가 가변파라미터인지 모르기때문이다.


//만약 Argument Label을 wildcard pattern으로 생략하면 어디까지 가변파라미터인지 모른다.
틀린예) func printSum(of nums: Int..., _ initValue: Int} {}   

맞는예) func printSum(of nums: Int..., initValue: Int} {}
	  printSum(of: 1, 2, 3, 4, initValue: 100)
	  
	  
-------------------------------------
또, 주의할 것은 가변파라미터는 기본값을 가질 수 없다.
또, 가변파라미터는 파라미터 한번만 쓸 수 있다.

틀린예) func printSum(of nums: Int..., nums2: Int...) {}

====================================================
#) Nested Function(중첩함수)
func outer() {
	print("outer")
	
	func inner() {
		print("inner")
	}
	inner()
}  //outer 함수내에서 inner() 함수를 실행할 수 있지만
   //outer 함수외부에서는 inner함수를 실행할 수 없다.
   
====================================================
#) 애플 문서에 나오는 함수 표기법
1) 파라미터가 있는 함수표기법
괄호안에 Argument Label을 써주고 옆에 :를 붙여줌

func sayHello(name: String )   { }            // sayHello(name:)
func sayHello(_ name: String ) { }            // sayHello(_:)
func sayHello(to name: String) { }            // sayHello(to:)
func sayHello(name: String, age: Int) { }     // sayHello(name:age:)

2) 파라미터가 없는 함수표기법
함수이름만 덩그라니 쓰면 끝임!!!  -> 함수표기법에서는 파라미터가 없을 시 호출할때 ()를 생략한다.

func sayHello() {}           //sayHello
func sayHelloToSodeul() {}   //sayHelloToSodeul

========================================================
#) 함수타입 - 파라미터가 없는 함수 타입
func sayHello() {}
sayHello  // () -> () 이렇게 반환된다. 파라미터도 없고 반환타입도 없기 때문에

#)파라미터가 있는 함수 타입
func sayHello(_ name: String) {}
sayHello(_:)  // (String) -> ()

#)파라미터가 여러개이고 리턴타입이 String일때
func sayHello(_ name: String, _ age: Int, alias: String) -> String {}
sayHello(_:_:alias:)   // (String, Int, String) -> String

#)가변파라미터 일떄 함수타입은
sum(of:) // (Int...) -> ()

#)입출력 파라미터의 경우
sum(a: b:) // (inout Int, inout Int) -> ()

========================================================
// 1. 일반적 함수
func normalFunc(name: String) {
}
// 함수호출
normalFunc(name: "나리")
// 함수이름: normalFunc(name:)

// 2. 전달인자 레이블을 사용한 함수
func usingArgumentLabelFunc(to name: String) {
}
// 함수호출
usingArgumentLabelFunc(to: "나리")
// 함수이름: usingArgumentLabelFunc(to:)


// 3. 전달인자 레이블을 와일드카드 식별자로 사용하는 함수 - 함수호출 시 자바에서처럼 호출
func usingWildCardLabelFunc(_ name: String) {
}
// 함수호출
usingWildCardLabelFunc("나리")
// 함수이름: usingWildCardLabelFunc(_:)

========================================================

#)일급객체함수
swift는 객체지향언어인 동시에 함수형 언어이다.
그렇기때문에 함수가 1급객체로 취급된다.

1급 객체로 되기 위한 조건이있다.
1) 변수나 상수에 함수를 대입할 수 있어야한다.
- 함수자체를 변수나 상수에 대입해서 변수나 상수가 함수 자체처럼 쓰이는 것을 말한다.

//함수이름으로 대입하기
func sayHello(_ name: String) {}
let f = sayHello

그러나, 이게 문제점이 sayHello라는 함수가 오버로딩이 된경우 문제가 발생한다. 어떤 함수인지 모른다.
func sayHello(_ name: String) {}
func sayHello(_ name: String, _ age: Int) {}
let f = sayHello //에러난다.

그래서, 타입 어노테이션을 통해 함수 타입을 명시해준다.
func sayHello(_ name: String) {}
func sayHello(_ name: String, _ age: Int) {}
let f: (String) -> () = sayHello

그러나, 이것도 문제가 있다.
아래처럼 파라미터 타입 & 리턴 타입마저 동일한 함수가 존재한다면??
이럴때 함수표기법을 통해 대입한다.
func sayHello(name: String) {}
func sayHello(_ name: String) {}
let f = sayHello(name:)

------------------------------------
여기서 중요한 것은 우린 f라는 상수에 함수를 대입한 것이지
sayHello라는 실행결과를 f에 대입한 것이 아니다.

따라서, f라는 상수에 저장된 것은 sayHello라는 함수이기 때문에 이 f를 통해서
우리가 저장한 함수를 실행시킬 수 있다.
f("Sodeul")

자, 또 중요한 것!

함수를 저장한 상수 f를 통해 함수를 호출할 땐 Argument Label을 사용하지 않음

왜냐? sayHello라는 함수 자체를 호출할 땐 당연히 Argument Label이 필요하지만,

sayHello를 f라는 상수에 넣는 순간 함수 타입만 가져가지, Argument Label까지 가져가진 않음

만약, 함수를 저장한 상수(변수)를 호출할 때 Argument Label을 사용하면
f(name: "Sodeul") //에러가 뜬다.

-----------------------------------------
#) 함수의 반환 타입으로 함수를 사용할 수 있다.
func outer() -> () -> () {
	func inner() {
		print("inner!")
	}
	return inner
}

outer란 함수가 inner라는 함수를 반환하고있다.
여기서 ()->()->() 의 의미는 

() ->            () -> ()
outer파라미터       outer리턴타입(inner함수타입)

let f = outer()
f() //inner! 출력

------------------------------------------
#) 함수의 파라미터로 함수를 전달할 수 있다. -> 콜백함수에서 사용
func doSomething(_ callback: () -> ()) {   //callback이 파라미터개념
	callback()  //Success!
}

//위에서 선언한 함수에게 두가지로 파라미터에 함수를 넘겨줄 수 있다.
1) 함수(Named Closure)로 넘겨주기
func success() {
	print("Success!")
}
doSomething(success)

2) 클로저(Unnamed Closure)로 넘겨주기
doSomething {
	print("Success")
}

---------------------
//파라미터가 있다면
func doSomething(_ callback: (String) -> ()) {
	callback("sodeul")
	callback("sodeul")
	callback("sodeul")
}
doSomething(message in
	print("Success!" + message)
}

//결과
Success!sodeul
Success!sodeul
Success!sodeul
============================================================================
#) defer -> 작성된 위치와 상관없이 함수 종료 직전에 실행되는 구문

func testDefer() {
	print("Check #1")
	
	defer { print("defer #1") }
	
	print("Check #2")
}

testDefer()  

//출력결과
Check #1
Check #2
defer #1

==========================================================================
#) defer를 읽기 전에 함수를 종료시키면 defer는 실행되지 않는다!!!

func testDefer() {
	print("Check #1")
	
	return;
	defer { print("defer #1") }
	
	print("Check #2")
}

testDefer()

//출력결과 -> 함수가 끝났기때문에 defer는 불리지 않는다.
Check #1

=======================================================================
#) 하나의 함수에서 여러번 defer를 호출 가능하며, 실행 순서는 가장 마지막에 실행된 defer부터 역순이다.

func testDefer() {
	defer { print("defer #1") }
	defer { print("defer #2") }
	defer { print("defer #3") }
}

testDefer()

//출력결과
defer #3
defer #2
defer #1

가장 마지막에 읽은 defer가 먼저 실행되고, 가장 처음 읽은 defer가 가장 마지막에 실행

=============================================================
#) defer는 중첩해도 사용가능하며, 실행순서는 가장 바깥쪽 defer부터 실행된다.

func testDefer() {
    defer {
        defer {
            defer {
                print("defer #3")
            }
            print("defer #2")
        }
        print("defer #1")
    }
}

//출력결과
defer #1
defer #2
defer #3

====================================================================
#) defer는 언제 사용할까??
함수를 종료하기 직전에 정리해야 하는 변수나 상수를 처리하는 용도

===================================================================
#)클로저의 표현식
익명함수인 만큼 func란 키워드를 쓰지 않는다.
{(parameters) -> Return Type in      //closure head  
	실행구문    //closure body
}
//head와 body를 구분지어주는게 in이다.
=====================================================================
#) parameter와 return type이 둘다 없는 클로저
클로저는 익명이긴 하지만 함수이다.

swift에서는 1급 객체이기 때문에, 상수에 클로저를 대입할 수 있다.
파라미터, 리턴타입이 둘다 없는경우는 이렇게 사용한다.
let closure = { () -> () in
	print("Closure")
}

========================================================================
#)parameter와 Return Type이 있는 클로저
let closure = {(name: String) -> String in 
	return "Hello, \(name)"
}

*) 함수때처럼 Paramter인 name은 단독으로 쓰였으니, Argument Label이자, ParameterName이라고 생각할수 있지만
클로저에선 Argument Label을 사용하지 않는다.
따라서, name은 Argument Label이 아니고, 오직 Paramter Name이다.
따라서 클로저를 호출할때는 Argument Label을 사용하지 않는다.
closure("Sodeul") 
closure(name: "Sodeul") //error


=========================================================================
#)1급 객체 클로저

1) 클로저를 변수나 상수에 대입할 수 있다.
let closure = { () -> () in
	print("Closure")
}

기존에 클로저를 대입한 변수나 상수를 이렇게 새로운 변수나 상수에 대입 가능
let closure2 = closure

--------------------------
2) 함수의 파라미터 타입으로 클로저를 전달 할 수 있다.
func doSomething(closure: () -> () {
	closure()
}

doSomething(closure: { () -> () in   //closure~ print까지가 클로저이다
	print("Hello");
}

---------------------------
3)함수의 반환타입으로 클로저를 사용할 수 있다.
func doSomething() -> () -> () {
	return { () -> () in    //클로저 리턴
		print("Hello Sodeul")
	}
}

또한
let closure = doSomething()
closure() //이렇게 호출하는 곳에서 클로저를 받아서 실행할 수도 있다.

===================================================================
4) 클로저 실행하기

첫번째방법.
- 클로저가 대입된 변수나 상수로 호출하기

let closure = { () -> String in 
	return "Hello Sodeul"
}

closure()

-------------------------------------
두번째방법.
- 클로저를 직접 실행하기
클로저를 변수나 상수에 대입하지 않고 실행시키고 싶다면,(완벽한 일회성)
그땐 클로저를 () 소괄호로 감싸고, 마지막에 호출 구문인 () 를 추가해주면 됨

({ () -> () in
	print("Hello Sodeul")
})()

=========================================================================
//Outlet, Action을 이용하면 코드에서 UI접근이 가능하다.
//스토리보드에서 버튼요소 클릭하고 우클릭해서 컨트롤러안에 끌어놓으면
//설정 할 수 있는 항목이 뜬다.
import UIKit

class ViewController: UIViewController {
    @IBOutlet weak var colorView: UIView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }

    @IBAction func tabChangeColorButton(_ sender: UIButton) {
        self.colorView.backgroundColor = UIColor.blue
        print("색상 변경이 클릭되었음") //이거는 콘솔에 찍힌다
    }
    
}
======================================================================
콘텐츠고유사이즈(가로,세로)가 늘어나는데 이때 늘어나는저항을 content hugging이라하고
더 줄어들게되는것에 저항하는것을 content compression resistance라고한다

우선순위가 있는데 휴깅은 우선순위가 높으면 내 크기를 유지하고 낮으면 크기가 늘어난다.(설정은 show the size inspector에 있다, 여러줄 입력 시 lines를 0으로 하면된다)
우리는 명언줄이 명언한사람이름보다 높이가 길어야하니 명언줄의 label의 크기를 늘이기 위해서는 명언한사람의 label우선순위인 251보다 낮게 250으로
설정해야 늘어나게된다.

명언줄 label에서 여러줄을 추가시키면 높이가 늘어나는데 밑에 명언하는사람의label이 줄어들게 할건지 물어본다(content compression resistance)
우리는 명언줄이 잘리더라도 명언한 사람의 label크기는 줄면 안되니까 명언한 사람의 label크기 우선순위를 1000으로 해서 압축을 저항해야한다.
설정은 content compression resistance priority에서 한다. (이 순위가 비교해서 낮아야 압축이안된다.)

import UIKit

class ViewController: UIViewController {
    
    //라벨과 버튼을 우클릭으로 끌어 당겨서 만들었다.
    @IBOutlet weak var quoteLabel: UILabel!
    @IBOutlet weak var namedLabel: UIButton!
    
    //버튼을 눌렀을 때 액션함수가 호출되야 하니까
    //즉, 명언생성을 끌어다 놓고 아래처럼 만들었다.
    //명언생성 버튼을 누르면 아래 액션함수가 실행된다.
    @IBAction func tapQuoteGeneratorButton(_ sender: Any) {
        
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }


}

=========================================================
//이제 명언 구조체를 만들어보자
//좌측에 QuotesGenerator폴더 우클릭하면 newFile -> swift -> Quote.swift이름으로 만든다.
//
//  Quote.swift
//  QuotesGenerator
//
//  Created by 조성동 on 2023/03/31.
//

import Foundation

struct Quote {
    let contents: String
    let name: String
}


----------------
//
//  ViewController.swift
//  QuotesGenerator
//
//  Created by 조성동 on 2023/03/31.
//

import UIKit

class ViewController: UIViewController {
    
    //라벨과 버튼을 우클릭으로 끌어 당겨서 만들었다.
    @IBOutlet weak var quoteLabel: UILabel! //명언
    @IBOutlet weak var nameLabel: UILabel!  //이름
    
    let quotes = [
        Quote(contents: "죽음을 두려워하는 나머지 삶을 시작조차 못하는 사람이 많다", name: "벤다이크"),
        Quote(contents: "나는 나 자신을 빼 놓고는 모두 안다", name: "비용"),
        Quote(contents: "편견이란 실효성이 없는 의견이다", name: "암브로스 빌"),
        Quote(contents: "분노는 바보들의 가슴속에서만 살아간다", name: "아인슈타인"),
        Quote(contents: "몇 번이라도 좋다! 이 끔찍한 생이여... 다시", name: "니체")
    ]
    
    //버튼을 눌렀을 때 액션함수가 호출되야 하니까
    //즉, 명언생성을 끌어다 놓고 아래처럼 만들었다.
    //명언생성 버튼을 누르면 아래 액션함수가 실행된다.
    @IBAction func tapQuoteGeneratorButton(_ sender: Any) {
        // 0~4까지의 랜덤한 수를 만들어낸다
        //배열의 인덱스 요소로 접근해야하니까 int형으로 치환
        let random = Int(arc4random_uniform(5))
        let quote = quotes[random]
        self.quoteLabel.text = quote.contents
        self.nameLabel.text = quote.name
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }


}

==============================================
IBOutlet은 스토리보드에 등록된 ui 오브젝트를 코드에 변수에 접근할 수 있도록 만들어준다.
IBAction은 버튼과 연결시켜 이벤트를 처리

===============================================
#)Content View Controller
- 화면을 구성하는 뷰를 직접 구현하고 관련된 이벤트를 처리하는 뷰 컨트롤러

#)Container View Controller
- 하나 이상의 Child View Controller를 가지고 있다.
- 하나 이상의 Child View Controller를 관리하고 레이아웃과 화면전환을 담당한다.
- 화면 구성과 이벤트관리는 Child View Controller에서 한다
- Container View Controller는 대표적으로 Navigation Controller 와 TabBar Controller가 있다.

#) Navigation Controller는 계층구조로 구성된 content를 순차적으로 보여주는데
예를들어 설정 > 기기관리 > vpn관리 같은것이다. vpn관리로 들어가면 기기관리 content는 덮어쓰고 뒤로가기하면 다시나타나는 형식이다.
Navigation Stack이라한다. 설정이 젤 밑에 쌓이고 기기관리가 그 위에 쌓인다.
vpn관리에서 뒤로가기버튼을 누르면 스택에 있는 vpn관리 Controller를 스택에서 제거할 수 있다.(pop)

========================================
#)화면전환하는 방식
1. 소스코드를 통해 전환하는 방식

2. storyboard에서 기본으로 제공하는 기능을 통해 전환하는 방식

#)세부적으로 4가지 방법이있다.
1. View Controller의 다른 View 위에 다른 View를 가져와 바꿔치기 -> 이 방법은 메모리 누수가 발생해서 거의 사용하지 않는다.
2. View Controller에서 다른 View Controller를 호출하여 전환하기 -> 기존 viewcontroller에 새로운 viewcontroller를 덮는방식
3. Navigation Controller를 사용하여 화면 전환하기
4. 화면 전환용 객체 세그웨어(segueway)를 사용하여 화면 전환하기 -> 스토리보드만으로 가능, 코드작성없이



=============================================
#) 실습(기존에 스토리보드에서 제공하는 걸 써보자)
1.app생성하면 mainStoryboard를 클릭하고 + 버튼을 클릭해서
  navigation controller를 버튼 추가하는 것처럼 검색해서 추가한다. -> navigation controller여서 상단에 네비게이션 바가 생성된다.
2.생성되면 root viewcontroller는 지운다.

여기까지가 navigation controller | viewController 화면이다.

3. 여기서 navigation controller에서 우클릭해서 viewcontroller로 끌어다놓으면 선택할 수 있는 항목이 생기는데 root viewcontroller선택하면된다.
4.추가된 navigation controller를 클릭해서 옆에 속성(inspector)을 보면 is initial view controller를 클릭하면 navigation controller가 최초의 화면이 된다.

이제버튼을 view controller에 추가해보자
버튼이름은 segue로 push, segue로 present, 코드로 push, 코드로 present
여기서 segue로 push는 스토리보드에서 화면전환용 segueway를 사용해서 navigation stack에 새로운화면은 push할것이다.
segue present는 segueway를 사용해서 navigation controller에 root viewcontroller화면위에 새로운 화면으로 덮어지게끔
코드로 push는 코드를 이용해서 navigation stack에 새로운 화면을 push할것이고 present는 navigation controller에 root viewcontroller화면위에 새로운 화면으로 덮어지게끔한다.

5. viewcontroller를 하나 더 추가해보자(uiviewcontroller 선택)

navigation controller | viewcontroller | viewcontroller
                          segue로 push       segue로 push
                          segue로 present    
                          코드로 push         back button
                          코드로 present
                          

back button을 누르게되면 popviewcontroller 메서드를 호출해서 이전화면으로 돌아가게 한다.

만든 viewcontroller를 옆에있는 view controller class에 연결시켜주기위해 
프로젝트 우클릭 - new file - cocoa - 이름은 SuguePushViewController, subclass of는 UIViewController로 선택

이렇게 되면
navigation controller | 1. viewcontroller | 2. SeguePushViewController    
                          segue로 push       segue로 push
                          segue로 present    
                          코드로 push         back button
                          코드로 present
        
6. SuguePushViewController에서(폰그림상단에 클릭) 속성(우측) - custom class - SuguePushViewContriller로 이름 설정, 그러면 옆에 main에 이름이 바뀜(Segue로)
viewcontroller(Seguepushviewcontroller) 클래스와 storyboard scene이 연결이된다.
7. 1.의 viewController에서 "Sugue로 Push"를 우클릭해서 드래그로 SuguePushViewController에 끌어놓으면 action segue항목에서 show클릭하면
   1.과 2.사이에 '->' 화살표가 생기면서 상단에 back 버튼이 생긴다.
여기서 화살표가 segueway인데 세그웨이는 단방향 화면전환이다. 
8. 컴파일해서 폰으로 보면 segue push 누르면 -> SuguePushView로이동 -> 상단 back(이거는 navigation controller의 navigation bar를 이용) -> viewController 자유롭게 이동한다.

현재구성이                                         
                                            -----ViewController-----              ----SuguePushViewController------
                                            |                                               <Back
                                            |   
-----navigation controller ----             |    Segue로 push(누르면이동)           ----->       segue로 push
|                         |                 |    ...                                         
|                         |       ----->     |                                                back button
|                         |
|                         |                   
---------------------------



이제 우리는 back button에 액션을 줄것이다.(상단에 <back 말고)
SuguePushViewController 위에 3개 아이콘이보이는데 첫번째선택 후 햄버거모양 클릭 - assistant 클릭하면
좌측에는 suguepush scene화면이(폰) 우측에는 SuguePushViewController class가 보인다.

좌측에서 이제
backbutton을 드래그해서 끌어당기면 SuguePushViewController 소스에 놓으면 아래처럼 된다.
버튼액션함수이름은 tapBackButton이다.

//
//  SeguePushViewController.swift
//  ScreenTransitionExample
//
//  Created by 조성동 on 2023/04/04.
//

import UIKit

class SeguePushViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

        // Do any additional setup after loading the view.
    }
    @IBAction func tapBackButton(_ sender: UIButton) {
        //BackButton누르면 이전화면으로(navigation controller의 popViewController메서드쓰면됨)
        
        self.navigationController?
            .popViewController(animated: true)
            
        //만약 navigation 스택의 첫번째로 가고싶으면?? -> root viewcontroller로이동하고싶을때
        self.navigationController?
            .popToRootViewController(animated: true) // 제일 처음 스택으로 간다.
    }
}


===============================================================
//이제 push present(segue로 present)를 써보자
//segueway를 이용해서 viewcontroller에서 다른 viewcontroller를 호출해서 화면을 전환해보자
//그러면 + 버튼으로 viewcontroller추가해보자(SuguePresentViewController)
여기까지가 아래화면 구성도이다.
                                            -----ViewController-----              ----SuguePushViewController------
                                            |                                               <Back
                                            |   
-----navigation controller ----             |    Segue로 push(누르면이동)           ----->       segue로 push
|                         |                 |                                                 
|                         |       ----->     |   Sugue로 present                               back button
|                         |
|                         |                   
---------------------------

                                                                            ----> -----SuguePresentViewController-----
                                                                                         
                                                                                          Sugue로 present(label)
                                                                                          back button



2. 프로젝트 파일 우클릭 - new file - cocoa touch class - 이름은 SuguePresentViewController
3. 만든 view Controller위에 네비게이션바 첫번째 동그라미 선택 - custom class에 이름을 SuguePresentViewController 라고 하고
4. 1.의 viewController에서 "Sugue로 present"를 드래그해서 SuguePresentViewController로 드래그해서 놓으면 segue방식은 present modally를 선택
이러면, 현재 화면(새로운 뷰컨트롤러로)으로 덮어씌워지게 된다.

5. back button을 활성화하기 위해 SuguePresentViewController 소스에 끌어다 놓으면 된다.(assistant를 켜서 좌측에는 모바일화면 - 우측에는 클래스코드)
//
//  SuguePresentViewController.swift
//  ScreenTransitionExample
//
//  Created by 조성동 on 2023/04/04.
//

import UIKit

class SuguePresentViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
    }
    
    //이렇게하면 밑에서 위로 올라가면서 새 화면이 뜨는데 모달형식으로 뜬다. 그래서 전체화면을 꽉안채운다.
    @IBAction func tapBackButton(_ sender: UIButton) {
        self.presentingViewController?
            .dismiss(animated: true, completion: nil)
    }
}

//그래서 전체화면으로 채울려면 컨트롤러에 연결되있는 선(1.에서 suguePresentViewcontroller로 연결되있는)을 
//클릭하고 속성에 Show the attributes inspector 항목에 presentation을 fullscreen으로 선택하면된다.
//viewController -----  SuguePresentViewController

========================================================
#) 이제 코드로 push를 구현해보자 -> navigation 스택에 새로운화면이 push되게

+버튼으로 viewcontroller 추가하자(label, button까지)

이제 viewcontroller 클래스를 만들자 -> 프로젝트폴더우클릭 -> new file -> cocoa touch class -> 이름은 CodePushViewController

그다음에 상단에 첫번째 동그라미 선택해서 custom class에 CodePushViewController로 이름넣자.
그다음에 rootviewController(1.의 viewcontroller) 의 "코드로 push" 항목을 클릭 한후에 assistant를 켜서
1. 의 "코드로 push"를 드래그 해서 1.의 viewcontroller class에 갖다놓으면된다.

import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
    }
    @IBAction func tapCodePushButton(_ sender: UIButton) { //"코드로 push" 버튼에 대한 액션
        //navigation 스택에 codePushviewController가 푸시되게끔해보자
        //먼저, 스토리보드에 있는 viewcontroller를 instance화 해줘야한다.
        //identifier매개변수에는 스토리보드 id를 넘겨줘야한다.
        //스토리보드id는 main story보드에서 codePushViewController를 클릭하면 속성에 custom class밑에
        //storyboardid 입력란이 있다. 거기에 CodePushViewController를 입력
        //이거를 identifier 매개변수에 아래처럼 입력
        guard let viewController = self.storyboard?.instantiateViewController(identifier: 
        "CodePushViewController") else { return }   
        self.navigationController?.pushViewController(viewController, animated: true) //위에서 instance화한 viewController를 넘긴다. 
        // 이렇게되면 navigation stack에 새로운화면이 푸시가된다.
        
    }
}


//이제 backbutton을 구현해보자
CodePushViewController 화면에서 assistant를 켜서 backbutton을 우측으로 드래그해서 놓는다.
import UIKit

class CodePushViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

    }
    @IBAction func tapBackButton(_ sender: UIButton) {
        self.navigationController?.popViewController(animated: true)
    }
}




//이제 마지막으로 "코드로 present'를 해보자
먼저 +버튼 - ViewController 추가 - label, button추가 - cocoa touch class추가 (이름은 CodePresentViewController)
- custom class에 CodePresentController 로 이름변경

//그 다음으로 1. 의 assistant 를켜서 "코드로 present" 드래그해서 놓자
import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
    }
    @IBAction func tapCodePushButton(_ sender: UIButton) { //"코드로 push" 버튼에 대한 액션
        
        guard let viewController = self.storyboard?.instantiateViewController(identifier: 
        "CodePushViewController") else { return }   
        self.navigationController?.pushViewController(viewController, animated: true) //위에서 instance화한 viewController를 넘긴다. 
    }
    
    @IBAction func tapCodePresentButton(_ sender: UIButton) {
        //스토리보드에 있는 viewContoller를 찾아서 인스턴스화
        //storyboard id는 CodePresentViewController에서 만들어야함(속성)
        guard let viewController = self.storyboard?.instantiateViewController
        (identifier: "CodePresentViewController") else {return}
        
        //전체화면으로 할려면
        viewController.modalPresentationStyle = .fullScreen
        
        //이제 인스턴스화한 viewcontroller를 넘기면된다.
        self.present(viewController, animated: true, completion: nil)
    }
}



//backbutton은 CodePresentViewController에서 backbutton을 해당 class에 드래그드랍
import UIKit

class CodePresentViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()

    }
    @IBAction func tapBackButton(_ sender: UIButton) {
        self.presentingViewController?.dismiss(animated: true, completion: nil)
    }
}

=================================================
ViewController Life Cycle
- Appearing: 뷰가 화면에 나타나는 중
- Appeared: 뷰가 화면에 나타나는게 완료된 상태
- Disappearing: 뷰가 화면에서 사라지는 중
- Disappeared: 뷰가 화면에서 사라진 상태

viewDidLoad()
- 뷰 컨트롤러의 모든 뷰들이 메모리에 로드됐을때 호출
- 메모리에 처음 로드될때 한번만 호출
- 보통 딱 한번 호출될 행위들을 이 메소드안에 정의함
- 뷰와 관련된 추가적인 초기화 작업, 네트워크호출(일회성작업)

viewWillAppear()
- 뷰가 뷰 계층에 추가되고, 화면에 보이기 직전에 매번 호출
- 다른 뷰로 이동했다가 돌아오면 재호출
- 뷰와 관련된 추가적인 초기화 작업

viewDidAppear()
- 뷰 컨트롤러의 뷰가 뷰 계층에 추가된 후 호출된다.
- 뷰를 나타낼 때 필요한 추가 작업
- 애니메이션을 시작하는 작업

viewWillDisappear()
- 뷰 컨트롤러의 뷰가 뷰 계층에서 사라지기전에 호출
- 뷰가 생성된 뒤 작업한 내용을 되돌리는 작업
- 최종적으로 데이터를 저장하는 작업

viewDidDisappear()
- 뷰 컨트롤러의 뷰가 뷰 계층에서 사라진 뒤에 호출
- 뷰가 사라지는 것과 관련된 추가 작업



import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        print("ViewController 뷰가 로드되었다.")
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        print("ViewController 뷰가 나타날 것이다.")
    }
    
    overried func ViewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        print("ViewController 뷰가 나타났다.")
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        print("ViewController 뷰가 사라질 것이다.")
    }
    
    overried func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        print("ViewController 뷰가 사라졌다.")
    }
    
    @IBAction func tapCodePushButton(_ sender: UIButton) { //"코드로 push" 버튼에 대한 액션
        
        guard let viewController = self.storyboard?.instantiateViewController(identifier: 
        "CodePushViewController") else { return }   
        self.navigationController?.pushViewController(viewController, animated: true) //위에서 instance화한 viewController를 넘긴다. 
    }
    
    @IBAction func tapCodePresentButton(_ sender: UIButton) {
        //스토리보드에 있는 viewContoller를 찾아서 인스턴스화
        //storyboard id는 CodePresentViewController에서 만들어야함(속성)
        guard let viewController = self.storyboard?.instantiateViewController
        (identifier: "CodePresentViewController") else {return}
        
        //전체화면으로 할려면
        viewController.modalPresentationStyle = .fullScreen
        
        //이제 인스턴스화한 viewcontroller를 넘기면된다.
        self.present(viewController, animated: true, completion: nil)
    }
}


//앱을 실행하면 아래처럼 뜬다.
ViewController 뷰가 로드되었다.
ViewController 뷰가 나타날 것이다.
ViewController 뷰가 나타났다.

//Segue로 Push버튼을 누르면
ViewController 뷰가 사라질 것이다.
ViewController 뷰가 사라졌다.

//상단에 back을 누르면
ViewController 뷰가 나타날 것이다.
ViewController 뷰가 나타났다.

여기서 viewDidLoad가 호출안되는 이유는 이미 rootviewControllerview가 메모리에 로드되었기때문에

================================================
//SeguePushViewController에는 어떻게 되는지 보자

import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        print("ViewController 뷰가 로드되었다.")
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        print("ViewController 뷰가 나타날 것이다.")
    }
    
    overried func ViewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        print("ViewController 뷰가 나타났다.")
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        print("ViewController 뷰가 사라질 것이다.")
    }
    
    overried func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        print("ViewController 뷰가 사라졌다.")
    }
    ...   
}

//앱 실행하고 sugue로 push 클릭하면
ViewController 뷰가 로드 되었다.
ViewController 뷰가 나타날 것이다.
ViewController 뷰가 나타났다.
SeguePushViewController 뷰가 로드되었다.
ViewController 뷰가 사라질 것이다.
SeguePushViewController 뷰가 나타날 것이다.
ViewController 뷰가 사라졌다.
SeguePushViewController 뷰가 나타났다.

//상단에 back을 누르면
SeguePushViewController 뷰가 사라질 것이다.
ViewController 뷰가 나타날 것이다.
SeguePushVIewController 뷰가 사라졌다.
ViewController 뷰가 나타났다.

//여기서 다시 segue로 push 버튼을 누르면
//다시 seguepushviewController가 로드되는데 그 이유는
//seguepushviewcontroller에서 이전화면으로 돌아가게되면 seguepushviewcontroller가
//메모리에서 삭제되기때문이다.
SeguePushViewController뷰가 로드되었다.
ViewController뷰가 사라질것이다.
SeguePushViewCOntroller 뷰가 나타날것이다.
ViewController 뷰가 사라졌다.
SeguePushVIewController 뷰가 나타났다.



===================================================
#)화면간 데이터전송
rootviewcontroller에서 codepush, codepresentcontroller로 데이터 전송해보자
CodePushControllerView, CodePresentControllerView에 label을 추가하자
만든라벨을 각각의 클래스에 드래그드랍

class CodePresentViewController: UIViewController {
    
    @IBOutlet weak var nameLabel: UILabel!  //끌어다놓은 라벨
    var name: String?
    
    override func viewDidLoad() {
        super.viewDidLoad()

    }
    @IBAction func tapBackButton(_ sender: UIButton) {
        self.presentingViewController?.dismiss(animated: true, completion: nil)
    }
}


class CodePushViewController: UIViewController {

    @IBOutlet weak var nameLabel: UILabel!  //끌어다놓은 라벨
    var name: String?
    
    override func viewDidLoad() {
        super.viewDidLoad()

    }
    @IBAction func tapBackButton(_ sender: UIButton) {
        self.navigationController?.popViewController(animated: true)
    }
}


//다운캐스팅을 통해(as) var name 을 쓸 수 있다.
import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        print("ViewController 뷰가 로드되었다.")
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        print("ViewController 뷰가 나타날 것이다.")
    }
    
    overried func ViewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        print("ViewController 뷰가 나타났다.")
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        print("ViewController 뷰가 사라질 것이다.")
    }
    
    overried func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        print("ViewController 뷰가 사라졌다.")
    }
    
    @IBAction func tapCodePushButton(_ sender: UIButton) { //"코드로 push" 버튼에 대한 액션
        
        guard let viewController = self.storyboard?.instantiateViewController(identifier: 
        "CodePushViewController") as? CodePresentViewController else { return }   
        
        //추가된부분
        viewController.name = "Gunter"
        
        self.navigationController?.pushViewController(viewController, animated: true) //위에서 instance화한 viewController를 넘긴다. 
    }
    
    @IBAction func tapCodePresentButton(_ sender: UIButton) {
        guard let viewController = self.storyboard?.instantiateViewController
        (identifier: "CodePresentViewController") as? CodePushViewController else {return}
        viewController.modalPresentationStyle = .fullScreen

        viewController.name = "Gunter"

        self.present(viewController, animated: true, completion: nil)
    }
}

//다른화면에 push, present되기전에 name property값을 넘겨주면 전환된 화면으로 데이터를 전달할 수 있다.
class CodePushViewController: UIViewController {

    @IBOutlet weak var nameLabel: UILabel!  //끌어다놓은 라벨
    var name: String?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        if let name = name {
            self.nameLabel.text = name
            self.nameLabel.sizeToFit()
        }

    }
    @IBAction func tapBackButton(_ sender: UIButton) {
        self.navigationController?.popViewController(animated: true)
    }
}

class CodePresentViewController: UIViewController {
    
    @IBOutlet weak var nameLabel: UILabel!  //끌어다놓은 라벨
    var name: String?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        if let name = name {
            self.nameLabel.text = name
            self.nameLabel.sizeToFit() //안잘려서 보이게끔
        }

    }
    @IBAction func tapBackButton(_ sender: UIButton) {
        self.presentingViewController?.dismiss(animated: true, completion: nil)
    }
}


//이러면 rootviewcontroller에서 "코드로 push" 를 클릭하면 rootviewcontroller에서 전달한 gunter가 잘보인다.

==========================================
//이전화면이 viewcontroller에 데이터전달해보자
일단 rootviewcontroller에 label을 하나 추가시키자

그 label을 viewController에 끌어다놓자.
class ViewController: UIViewController {

    //추가된부분
    @IBOutlet weak var nameLabel: UILabel!

    override func viewDidLoad() {
        super.viewDidLoad()
        print("ViewController 뷰가 로드되었다.")
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        print("ViewController 뷰가 나타날 것이다.")
    }
    
    overried func ViewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        print("ViewController 뷰가 나타났다.")
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        print("ViewController 뷰가 사라질 것이다.")
    }
    
    overried func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        print("ViewController 뷰가 사라졌다.")
    }
    
    @IBAction func tapCodePushButton(_ sender: UIButton) { //"코드로 push" 버튼에 대한 액션
        
        guard let viewController = self.storyboard?.instantiateViewController(identifier: 
        "CodePushViewController") as? CodePresentViewController else { return }   
        
        viewController.name = "Gunter"
        
        self.navigationController?.pushViewController(viewController, animated: true) //위에서 instance화한 viewController를 넘긴다. 
    }
    
    @IBAction func tapCodePresentButton(_ sender: UIButton) {
        guard let viewController = self.storyboard?.instantiateViewController
        (identifier: "CodePresentViewController") as? CodePushViewController else {return}
        viewController.modalPresentationStyle = .fullScreen

        viewController.name = "Gunter"

        self.present(viewController, animated: true, completion: nil)
    }
}


//이제 codepresentview에서 이전화면인 viewcontroller로 데이터를 전달해보자

protocol SendDataDelegate: AnyObject {
    func sendData(name: String)
}

class CodePresentViewController: UIViewController {
    
    @IBOutlet weak var nameLabel: UILabel!  //끌어다놓은 라벨
    var name: String?
    
    //프로토콜타입변수 정의
    //delegate패턴을 쓸때는 delegate변수앞에 weak를 붙여줘야한다. 강한 순환참조 때문에 메모리 누수
    weak var delegate: SendDataDelegate? 
    
    override func viewDidLoad() {
        super.viewDidLoad()
        if let name = name {
            self.nameLabel.text = name
            self.nameLabel.sizeToFit() //안잘려서 보이게끔
        }

    }
    @IBAction func tapBackButton(_ sender: UIButton) {
        self.delegate?.sendData(name: "Gunter")  //deletegate의 함수이용해서 데이터넘김
        self.presentingViewController?.dismiss(animated: true, completion: nil)
    }
}


//다시 viewcontroller를 보자
class ViewController: UIViewController, SendDataDelegate {

    @IBOutlet weak var nameLabel: UILabel!

    override func viewDidLoad() {
        super.viewDidLoad()
        print("ViewController 뷰가 로드되었다.")
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        print("ViewController 뷰가 나타날 것이다.")
    }
    
    overried func ViewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        print("ViewController 뷰가 나타났다.")
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        print("ViewController 뷰가 사라질 것이다.")
    }
    
    overried func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        print("ViewController 뷰가 사라졌다.")
    }
    
    @IBAction func tapCodePushButton(_ sender: UIButton) { //"코드로 push" 버튼에 대한 액션
        
        guard let viewController = self.storyboard?.instantiateViewController(identifier: 
        "CodePushViewController") as? CodePresentViewController else { return }   
        
        viewController.name = "Gunter"
        
        self.navigationController?.pushViewController(viewController, animated: true) //위에서 instance화한 viewController를 넘긴다. 
    }
    
    @IBAction func tapCodePresentButton(_ sender: UIButton) {
        guard let viewController = self.storyboard?.instantiateViewController
        (identifier: "CodePresentViewController") as? CodePushViewController else {return}
        viewController.modalPresentationStyle = .fullScreen

        viewController.name = "Gunter"
        
        //다른화면이 호출되기 전에 delegate를 위임받자(위임받을려면 클래스옆에 프로토콜채택해야됨)
        viewController.delegate = self
        
        self.present(viewController, animated: true, completion: nil)
    }
    
    //프로토콜을 준수하기 위해서
    func sendData(name: String) {
        self.nameLabel.text = name
        self.nameLabel.sizeToFit() //텍스트에 맞게 라벨사이즈 조절
    }
}

//실행을 해보면 viewcontroller에서 "코드로 present"를 클릭하고 backbutton을 클릭하면
//viewcontroller 라벨에 받은 Gunter 라고 적혀있다.
//이렇게 delegate패턴을 이용하면 이전화면으로 데이터를 전달할 수 있다.

=========================================================
#)이제 segueway 방식에서의 값을 전달해보자
//먼저, seguepushcontroller에서 label을 하나추가한다.
//assistant를 켜서 seguepushcontroller에서 만든 라벨을 끌어다 seguepushviewcontroller에 가져다 놓는ㄷ다,
class SeguePushViewController: UIViewController {
    //추가된 라벨부분
    @IBOutlet weak var nameLabel: UILabel!
    
    //segueway방식에서 전환되는 화면으로 데이터 전달하는 제일좋은 위치는
    //prepare메서드이다. segueway실행직전에 시스템에 의해 자동호출된다.
    //그럼 이제 viewcontroller에서 설정해보자
    
    override func viewDIdLoad() {
        super.viewDidLoad()
        print("SeguePushViewController 뷰가 로드되었다")
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        print("SeguePushViewController 뷰가 나타날 것이다.")
    }
    
    overried func ViewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        print("SeguePushViewController 뷰가 나타났다.")
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        print("SeguePushViewController 뷰가 사라질 것이다.")
    }
    
    overried func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        print("SeguePushViewController 뷰가 사라졌다.")
    }
    
    @IBAction func _tapBackButton(_ sender: UIButton) {
        self.navigationController?.popViewController(animated: true)
    }
    
}



class ViewController: UIViewController, SendDataDelegate {

    @IBOutlet weak var nameLabel: UILabel!

    override func viewDidLoad() {
        super.viewDidLoad()
        print("ViewController 뷰가 로드되었다.")
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        print("ViewController 뷰가 나타날 것이다.")
    }
    
    overried func ViewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        print("ViewController 뷰가 나타났다.")
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        print("ViewController 뷰가 사라질 것이다.")
    }
    
    overried func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        print("ViewController 뷰가 사라졌다.")
    }
    
    @IBAction func tapCodePushButton(_ sender: UIButton) { //"코드로 push" 버튼에 대한 액션
        
        guard let viewController = self.storyboard?.instantiateViewController(identifier: 
        "CodePushViewController") as? CodePresentViewController else { return }   
        
        viewController.name = "Gunter"
        
        self.navigationController?.pushViewController(viewController, animated: true) //위에서 instance화한 viewController를 넘긴다. 
    }
    
    @IBAction func tapCodePresentButton(_ sender: UIButton) {
        guard let viewController = self.storyboard?.instantiateViewController
        (identifier: "CodePresentViewController") as? CodePushViewController else {return}
        viewController.modalPresentationStyle = .fullScreen

        viewController.name = "Gunter"
        
        //다른화면이 호출되기 전에 delegate를 위임받자(위임받을려면 클래스옆에 프로토콜채택해야됨)
        viewController.delegate = self
        
        self.present(viewController, animated: true, completion: nil)
    }
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        //전환하려는 viewcontroller의 인스턴스를 가져올수있다, 다운캐스팅해주자
        if let viewController = segue.destination as? SuguePushViewController {
            viewController.name = "Gunter"
        }
    }
    
    
    //프로토콜을 준수하기 위해서
    func sendData(name: String) {
        self.nameLabel.text = name
        self.nameLabel.sizeToFit() //텍스트에 맞게 라벨사이즈 조절
    }
}





//다시 SeguePushViewController에서 설정

class SeguePushViewController: UIViewController {
    @IBOutlet weak var nameLabel: UILabel!
    var name: String?
    
    override func viewDIdLoad() {
        super.viewDidLoad()
        print("SeguePushViewController 뷰가 로드되었다")
        //전달받은 값을 label에 띄워보자
        if let name = name {
            self.nameLabel.text = name
            self.nameLabel.sizeToFit()
        }
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        print("SeguePushViewController 뷰가 나타날 것이다.")
    }
    
    overried func ViewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        print("SeguePushViewController 뷰가 나타났다.")
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        print("SeguePushViewController 뷰가 사라질 것이다.")
    }
    
    overried func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        print("SeguePushViewController 뷰가 사라졌다.")
    }
    
    @IBAction func _tapBackButton(_ sender: UIButton) {
        self.navigationController?.popViewController(animated: true)
    }
    
}

//이렇게되면 SeguePushViewCOntroller의 label에 잘찍힌다.
===============================================================
#) LED 전광판 만들기(LEDBoard project)
프로젝트만들고  -> mainstroyboard에 가서 +버튼으로 navigation 추가 후 기존에 navigation이랑
연결되있는 controller는 지운다. 그 후 화살표를(진입점) navigation controller로 옮긴다


#)화면구성
 --->(진입점) navigation controller  |   viewcontroller

그 후 navigation controller 우클릭 끌어당겨서 viewcontroller에 놓으면 항목이 생기는데
segueway메뉴에서 root view controller로 선택하고 놓는다.
이렇게되면 오른쪽의 viewcontroller가 navigation controller의 root view controller가 된다.

그 후 viewcontroller에 label을 하나 추가시키자(중앙에)
여기까지 화면구성이 아래와같다.

--> 1. navigation controller --> 2. viewcontroller
                                       label
                                  

여기서 viewcontroller를 클릭하고 속성에서 background를 black으로 한다.
이러면 label이 안보인다. 좌측에 viewcontrollerscene에서 label 클릭후 색상바꾼다.
그후 viewcontroller 상단에 네비게이션쪽을 클릭한 후에 + 버튼 -> 
bar button item 추가(휴대폰 우측 모서리 상단에 끌어다놓기) -> 이름을 설정으로 변경


------------
#)이제 설정으로 들어갔을 때 화면구성해보자
먼저 mainstoryboard에 viewcontroller를 하나 추가하자

--> 1. navigation controller --> 2. viewController  --> 3. viewController
                                       label

그다음에  2.의 viewcontroller에서 만들었던 상단의 설정 버튼을 우클릭드래그해서 3.에 놓으면된다.
그러면 segue선택항목에 show 클릭하면된다. 그러면 좌측상다네<back 버튼이생긴다.

그다음에 3.의 viewcontroller에서 label, textfield를 추가한다.
textfiled는 한줄밖에 입력안된다. 여러줄할려면 UITextview객체 이용해야함

그다음에 label, textfied를 하나로 묶을 것이다. 이 두개의 UIObject를 stackview로 묶는방법은
두개를 드래그해서 선택한다음에 맨아래에 Embed in view -> stack view 클릭
이렇게되면 두개의 uiobject가 stackview로 묶이게된다.



--> 1. navigation controller --> 2. viewController  --> 3. viewController
                                       label                label
                                                            textfield
                                                            
//그 다음에 옆에 속성에서 stackview로 잡힌상태에서 속성에 spcing을 통해 lable, textfield 간격을
//15로해서 줄인다.

#)label, button 추가

3. viewController
전광판에 표시할 글자(label)

|-------------|  (textfield)
|-------------|

텍스트 색상 설정   (label)
 
노란색 자주색 초록색  (button)


//그다음에 노란색, 자주색, 초록색 버튼들을 stackview로 묶고
//그 묶은거에다가 텍스트 색상 설정까지 묶는다.
//그 다음에 만든 stackview를 복사해서 하나 더 만든다.
//거기에 버튼(저장) 추가

전광판에 표시할 글자(label)

|-------------|  (textfield)
|-------------|

텍스트 색상 설정   (label)
 
노란색 자주색 초록색  (button)


배경 색상 설정 (label)

검정색 파란색 주황색  (button)
        
        저장
        
===============================================
//설정화면을 좀 더 예쁘게 꾸며보자


                                                     
 





















